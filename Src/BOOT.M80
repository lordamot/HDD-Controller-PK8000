ASEG


include const.i80



MAX_NAME_LEN    equ 29          ; макс. длина имени устройства
CPM_TYPE        equ 2           ; код типа основного раздела CP/M


REG_MODE        equ 53h         ; управляющий регистр
REG_LOBYTE      equ 52h         ; C - регистр младшего байта данных
REG_HIBYTE      equ 51h         ; B - регистр старшего байта данных
REG_LINE        equ 50h         ; A - регистр управляющих линий

MODE_READ       equ 8Bh         ; режим чтения данных на устройство
MODE_WRITE      equ 80h         ; режим записи данных на устройство

; биты регистра A
LINE_CS0        equ (1 shl 3)
LINE_CS1        equ (1 shl 4)
LINE_WR         equ (1 shl 5)
LINE_RD         equ (1 shl 6)
LINE_RESET      equ (1 shl 7)


ISREG8 macro par
    ISREG SET 0
    IRPC X, <ABCDEHLM>
      IFIDN <"&X">,<"&par">
        ISREG SET 1
      ENDIF
    ENDM
endm


OUTP macro port, data
    IFDIF <"&data">,<"A">
      ISREG8 data
      IF ISREG
        mov     A, data
      ELSE
        mvi     A, data
      ENDIF
    ENDIF
        out     port
endm

INP macro reg, port
        in      port
    IFDIF <"&reg">,<"A">
        mov     reg, A
    ENDIF
endm




        ORG 4000h

        db      "AB"
        dw      Begin

        ORG     HDD_FUNC_TABLE
        jmp     sv_SetDisk
        jmp     sv_SetAddr
        jmp     sv_Read
        jmp     sv_Write
        jmp     sv_cacheSec
        jmp     sv_Load_BDOS_CPP
        jmp     sv_CONIN
        jmp     sv_CONOUT
        jmp     sv_Reset

Begin:
        ; сохраняем стэк на случай возврата в интерпритатор
        pop     H
        shld    retAddr
        lxi     h, 0
        dad     sp
        shld    savedSP
        call    isBreak         ; проверяем нажатие 'ПРФ'
        ; самая важная часть любой программы - вывод копирайта
        lxi     H, szCopyright
        mvi     A, 2
        call    50h
        call    isBreak         ; проверяем нажатие 'ПРФ'
        ; переносим код в ОЗУ
        lxi     H, BEGINCPM
        lxi     D, CCP_ADDR
        lxi     B, SYS_SIZE+BIOS_SIZE ; CPM.SYS + BIOS.SYS
        call    5Ch
        call    isBreak         ; проверяем нажатие 'ПРФ'

        in      80h             ; запоминаем текущую конфигурацию
        sta     callMap         ; расположения памяти

        ; проверка целостности данных в ПЗУ
        call    mem_CheckCRC
        jc      Quit

        ; ищем и подключаем устройства
        call    ide_Detect
        jnc     BIOS_ADDR


Quit:   ; ничего не нашли, уходим в интерпритатор
        ei
        lxi     H, szExit
        mvi     A, 2
        call    50h
        call    7Ch

Exit:
        di
        lhld    savedSP
        sphl
        lhld    retAddr         ; HL - адрес возврата
        ei
        pchl



  szCopyright:  db 0Ch, 19h, 0Fh, "Press 'ПРФ' to break.",0Bh, "IDE BIOS ПК8000 1.5"
  szCRLF:       db 13,10,0
  szExit:       db 19h, 0Fh, "Press any key to exit...",0


; проверяем нажатие 'ПРФ'
; на выходе:
;       ZF      - 0: не нажата
;                 1: нажата
isBreak:
        mvi     A, 7
        call    47h
        ani     00000100b       ; ПРФ нажат?
        rnz                     ; -> нет, не нажата
        jmp     Exit


;========================================================================
; проверка целостности данных в ПЗУ
;========================================================================
;    CF         - 0: нормальное завершение
;                 1: неверный CRC
mem_CheckCRC:
        call    isBreak         ; проверяем нажатие 'ПРФ'
  IF CHECK_MEM eq 0
        ret
  ENDIF
        lxi     H, szTestMem
        mvi     A, 2
        call    50h
        lxi     H, 4000h
        lxi     B, BEGINCPM-4000h+SYS_SIZE+BIOS_SIZE
        mvi     D, 0
    @add_crc:
        mov     A, D
        add     M
        mov     D, A
        inx     H
        dcx     B
        mov     A, B
        ora     C
        jnz     @add_crc
        ora     D
        jnz     @mem_badCRC
        ; выводим сообщение о успешном тестировании
        lxi     H, szGoodMem
        mvi     A, 2
        call    50h
        call    isBreak         ; проверяем нажатие 'ПРФ'
        xra     A               ; CF = 0
        ret
    @mem_badCRC:
        push    PSW
        lxi     H, szBadMem
        lxi     D, strBuff
        lxi     B, len_bad_mem
        call    5Ch
        pop     PSW
        mov     L, A
        mvi     H, 0
        lxi     D, strBuff + (szBadCode-szBadMem)
        call    utoa
        lxi     H, strBuff
        mvi     A, 2
        call    50h
        stc
        ret

  szTestMem:    db "Test ROM ... ", 0
  szGoodMem:    db "ok.",13,10,0
  szBadMem:     db "bad crc: "
  szBadCode:    db "   ",13,10,0
  len_bad_mem   equ $-szBadMem


;========================================================================
;------------------------------------------------------------------------
;----------------- Поиск устройств и монтирование дисков ----------------
;------------------------------------------------------------------------
;========================================================================

;------------------------------------------------------------------------
; поиск устройств на канале и монтирование логических дисков
;------------------------------------------------------------------------
; на выходе:
;    CF         - 0: нормальное завершение
;                 1: ничего не нашли
ide_Detect:
        lxi     H, szReset
        mvi     A, 2
        call    50h
        call    ide_Reset       ; сброс устройств
        jc      @dev_notfound
        lxi     H, ALV
        shld    curALV
        xra     A
        sta     numDisks
        call    @find_device
    IF SLAVE_ENABLE ne 0
        mvi     A, 1
        call    @find_device
        xra     A
        sta     curDevice
    ENDIF
        lda     numDisks
        ora     A
        rnz
    @disk_notfound:             ; CP/M дисков не обнаружено
        lxi     H, szDskNotFnd
        jmp     @@det_printerr
    @dev_notfound:              ; ничего не обнаружили
        lxi     H, szDevNotFnd
    @@det_printerr:
        mvi     A, 2
        call    50h
        stc
        ret

    ; A - номер устройства на канале
    @find_device:
        sta     curDevice
        ; воводим master/slave
        mov     E, A
        mvi     D, 0
        lxi     H, lpszDev
        dad     D
        dad     D
        mov     E, M
        inx     H
        mov     D, M
        xchg                    ; HL = lpszDev[nDevice]
        mvi     A, 2
        call    50h
        ; пытаемся получить идентификационные данные от устройства
        lxi     H, IOBuff
        call    ide_Identify
        jc      @not_found
        call    ide_getParams   ; выбираем с буфера параметры устройства
        jc      @bad_geom
        call    inf_Print       ; выводим информацию о устройстве
        call    ide_ParseMBR    ; монтируем логические диски
        jc      @bad_mbr
        ret
    @not_found:                 ; устройство не обнаружено
        lxi     H, szNone
    @detect_printerr:
        mvi     A, 2
        call    50h
        ret
    @bad_geom:                  ; неправильная геометрия винта, или ошибка обмена
        lxi     H, szBadGeom
        jmp     @detect_printerr
    @bad_mbr:
        lxi     H, szBadMBR
        jmp     @detect_printerr


  lpszDev:      dw szMaster, szSlave
  szReset:      db "Reset...", 0
  szMaster:     db 0Fh, "Master: ", 0
  szSlave:      db "Slave:  ", 0
  szNone:       db "none.", 13,10,0
  szBadGeom:    db "bad geometry.", 13,10,0
  szDevNotFnd:  db 0Fh, "Devices not found!",13,10,0
  szDskNotFnd:  db 0Fh, "CP/M disks not found!",13,10,0
  szBadMBR:     db "read (S)MBR error.",13,10,0



;------------------------------------------------------------------------
; выбор режима работы с устройством(CHS или LBA)
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер с идентификационными данными
; на выходе:
;    SecPerTrack- количество секторов на дорожку
;    NumHeads   - биты:
;                   0..5 - количество головок
;                   6    - флаг (0 - режим CHS, 1 - режим LBA)
;    CF         - 1: ошибка - неверные данные геометрии устройства
ide_getParams:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        push    H
        lxi     D, 3*2
        dad     D
        mov     A, M
        sta     NumHeads
        dad     D
        mov     E, A            ; E = NumOfHeads
        mov     A, M
        sta     SecPerTrack
        mov     D, A            ; D = SecPerTrack
        ; проверяем корректность данных
        pop     H
        mvi     A, 63
        cmp     D
        rc
        mvi     A, 16
        cmp     E
        rc
        ; определяем режим чтения\записи
        push    H
        lxi     D, 60*2
        dad     D
        mov     A, M            ; Buff[60*2] - total sectors in LBA mode
        inx     H
        ora     M               ; Buff[60*2+1]
        inx     H
        ora     M               ; Buff[60*2+2]
        inx     H
        ora     M               ; Buff[60*2+3]
        pop     H
        rz
        ; устройство поддерживает LBA
        lda     NumHeads
        ori     40h
        sta     NumHeads
        ret




;------------------------------------------------------------------------
; поиск в MBR подразделов CP/M
;------------------------------------------------------------------------
; на входе:
;    curDevice  - текущее устройство
ide_ParseMBR:
        ; читаем нулевой сектор
        lxi     H, 0
        shld    absSector+2
        shld    absSector
        lxi     H, IOBuff
        call    ide_ReadSector
        rc
        call    ide_CheckSign   ; провряем сигнатуру сектора (AA55h)
        rc
        ; сохраняем адреса разделов
        lxi     D, 1BEh
        dad     D               ; HL - первый раздел
        lxi     D, Partions
        lxi     B, 16*4
        call    5Ch             ; wrBuff[0..3F] - записи разделов MBR
        ; проходимся по всем 4-м разделам
        mvi     A, 4
        sta     partCnt
        lxi     H, Partions+4   ; HL - на код типа раздела
    @@part_loop:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        shld    curPartion
        mov     A, M            ; проверяем тип раздела
        call    ide_IsPrimary   ; основной?
        jz      @@next_part
        cpi     05h             ; Extended dos 3.3?
        jz      @@do_SMBR
        cpi     0Ch             ; Extended win98?
        jz      @@do_SMBR
        cpi     0Fh             ; Extended win95?
        jnz     @@next_part
    @@do_SMBR:
        lxi     D, 4
        dad     D               ; HL - указатель на адрес и размер раздела SMBR
        call    ide_ParseSMBR   ; подключаем раздел
    @@next_part:
        lhld    curPartion
        lxi     D, 16
        dad     D
        lda     partCnt
        dcr     A
        sta     partCnt
        jnz     @@part_loop
        xra     A               ; clear carry
        ret

ide_IsPrimary:
        cpi     01h
        jz      @@primary
        cpi     04h
        jz      @@primary
        cpi     06h
        jz      @@primary
        cpi     0Bh
        jz      @@primary
        cpi     0Eh
        rnz
    @@primary:
        push    H
        lxi     H, szPrimary
        mvi     A, 2
        call    50h
        pop     H
        xra     A
        ret

  szPrimary:    db 9, "- skip primary.",13,10,0


;------------------------------------------------------------------------
; сканирует раздел и монтирует найденные логические диски
;------------------------------------------------------------------------
; на входе:
;    HL         - указатель на адрес SMBR
ide_ParseSMBR:
        ; сохраняем базу
        lxi     D, baseAddr
        call    m_Copy32
        lxi     H, baseAddr
        lxi     D, relAddr
        call    m_Copy32
    @@loop_smbr:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        ; считыаем очередной сектор SMBR
        lxi     H, relAddr
        lxi     D, absSector
        call    m_Copy32                ; absSector = relAddr
        lxi     H, IOBuff
        call    ide_ReadSector
        rc
        call    ide_CheckSign   ; провряем сигнатуру сектора (AA55h)
        rc
        ; сохраняем описатели диска и следующего раздела
        lxi     D, 1BEh
        dad     D
        lxi     D, secPartions
        lxi     B, 16*2
        call    5Ch
        ; проверяем код типа диска
        lxi     H, secPartions+4
        mov     A, M
        cpi     CPM_TYPE                ; это CP/M диск?
        jnz     @@next_smbr
        ; монтируем диск
        lxi     H, secPartions+8        ; relAddr
        lxi     B, relAddr
        call    m_Add32                 ; AbsAddr = smbr[0].relAddr + relAddr
        lxi     H, secPartions+8
        call    ide_MountDisk
        ; переходим к следующему элементу списка SMBR
    @@next_smbr:
        lxi     H, secPartions+16+4
        mov     A, M
        ora     A                       ; конец списка?
        rz
        lxi     H, secPartions+16+8
        lxi     D, relAddr
        call    m_Copy32
        lxi     H, relAddr
        lxi     B, baseAddr
        call    m_Add32                 ; relAddr = smbr[1].relAddr + baseAddr
        jmp     @@loop_smbr



;------------------------------------------------------------------------
; монтирует в систему логический диск
;------------------------------------------------------------------------
; на входе:
;    HL         - указатель на адрес первого сектора и размер диска в секторах
ide_MountDisk:
        ; считываем первый сектор логического диска
        lxi     D, absSector
        call    m_Copy32
        lxi     H, IOBuff
        call    ide_ReadSector
        rc
        ; проверяем сигнатуру раздела
        lxi     D, szDiskSys            ; "CP/M    "
        lxi     B, 8
        call    m_Compare
        rnz
        ; осталось ли место под диски?
        lda     numDisks
        cpi     NDISK
        jnc     @@not_space             ; -> мест нет
        ; переносим DPB
        mov     L, A
        mvi     H, 0
        dad     H               ; numDisks*2
        dad     H               ; numDisks*4
        dad     H               ; numDisks*8
        push    H               ; save (numDisks*8)
        dad     H               ; numDisks*16
        push    H
        lxi     D, DPBADDR
        dad     D
        xchg                    ; DE = &DPB[numDisks]
        lxi     H, IOBuff+8     ; HL = &DPB
        lxi     B, 16
        call    5Ch
        ; корректируем ALV в текущей DPH
        pop     H               ; HL = numDisks*16
        lxi     D, DPHADDR+14
        dad     D               ; HL = &DPH.ALV
        lda     curALV
        mov     M, A
        inx     H
        lda     curALV+1
        mov     M, A
        ; корерктируем указатель ALV
        lhld    IOBuff+8+5      ; Disk maximum
        inx     H
        xchg
        mvi     B, 3
        call    m_Shr16
        inx     D               ; DE = (DSM+1) / 8 + 1
        lhld    curALV
        dad     D
        push    H
        ; проверяем на переполнение буфера ALV
        lxi     D, -(ENDALV-1)  ; FIX: -(ALV+2047)
        dad     D
        pop     H
        jc      @@not_space
        shld    curALV
        ; настраивам tblDevices
        pop     H               ; HL = numDisks*8
        lxi     D, tblDevices
        dad     D
        xchg                    ; DE = &tblDevices[numDisks]
        lda     curDevice
        stax    D               ; tblDevices[numDisks][0] = curDevice
        inx     D
        lxi     H, absSector
        call    m_Inc32         ; absSector++
        lxi     H, absSector
        call    m_Copy32        ; tblDevices[numDisks][1] = absSectors
        lxi     H, IOBuff+8     ; HL = &DPB
        call    calck_Shift     ; tblDevices[numDisks][5] = shift
        lda     SecPerTrack
        stax    D
        inx     D
        lda     NumHeads
        stax    D
;        inx     D
        ; выводим сообщение о успешном монтировании
        lxi     H, szMount1
        mvi     A, 2
        call    50h
        lda     numDisks
        inr     A
        sta     numDisks
        adi     'A'-1
        call    3Bh
        lxi     H, szMount2
        mvi     A, 2
        call    50h
        ret
    @@not_space:
        pop     H               ; очищаем стэк
        ; выводим сообщение о неудаче
        lxi     H, szNoSpace
        mvi     A, 2
        call    50h
        ret

  szMount1:     db 9, "- mount [",0
  szMount2:     db "]",13,10,0
  szNoSpace:    db 9, "- no space, skip.",13,10,0
  szDiskSys:    db "CP/M    "   ; сигнатура первого сектора CP/M диска



;========================================================================
;------------------------------------------------------------------------
;--------------------------- Дисковые функции ---------------------------
;------------------------------------------------------------------------
;========================================================================

ide_ReadMode:
        di
        OUTP    REG_MODE, <MODE_READ>   ; режим чтения
        OUTP    REG_LINE, <0>
        ei
        ret

ide_WriteMode:
        di
        OUTP    REG_MODE, <MODE_WRITE>  ; режим записи
        OUTP    REG_LINE, <0>
        ei
        ret

;------------------------------------------------------------------------
; чтение регистра статуса контроллера устройства
;------------------------------------------------------------------------
; на выходе:
;    A          - регистр статуса
ide_GetStatus:
        di
        OUTP    REG_LINE, <LINE_CS0 + 7>
        OUTP    REG_LINE, <LINE_CS0 + LINE_RD + 7>
        INP     A, REG_LOBYTE
        push    PSW
        OUTP    REG_LINE, <LINE_CS0 + 7>
        OUTP    REG_LINE, <0>
        pop     PSW
        ei
        ret



;------------------------------------------------------------------------
; Поиск устройства на канале
;------------------------------------------------------------------------
; на входе:
;    curDevice  - номер устройства (0 - master, или 1 - slave)
;    HL         - буфер под данные о устройстве
; на выходе:
;    CF         - 0: нормальное завершение
;                 1: ошибка
ide_Identify:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        push    D
        lxi     D, chsAddress
        xra     A
        sta     chsAddress
        sta     chsAddress+1
        sta     chsAddress+2
        sta     chsAddress+3
        sta     NumHeads
        mvi     A, 0ECh
        sta     ataCommand
        call    ide_SendParam
        jc      @idn_error
        ; читаем регистр состояния и ждем готовности к приему данных
        call    ide_ReadMode    ; режим чтения
        lxi     D, 0FFFFh
    @idn_wait:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        dcx     D
        mov     A, D
        ora     E
        jz      @idn_error
        ; читаем регистр статуса
        call    ide_GetStatus
        ani     10001001b
        cpi     00001000b
        jnz     @idn_wait
        ; читаем данные
        call    ide_ReadBlock
        call    wait_bsy        ; ожидаем готовности устройства
        xra     A
        pop     D
        ret
    @idn_error:
        stc
        pop     D
        ret


;------------------------------------------------------------------------
; Чтение сектора
;------------------------------------------------------------------------
; на входе:
;    curDevice  - номер устройства на канале (0 или 1)
;    absSector  - абсолютный номер сектора
;    HL         - буфер для чтения
; на выходе:
;    CF         - 0: нормальное завершение
;                 1: ошибка
ide_ReadSector:
        ; "нормализуем" адрес
        call    ide_getAddress  ; HL - address
        ; отсылаем команду контроллеру
        mvi     A, 20h          ; команда чтения сектора с повтором
        sta     ataCommand
        call    ide_SendParam
        rc
        call    wait_drq        ; ждем готовности устройства к передаче данных
        rc
        ; читаем сектор
        call    ide_ReadBlock
        call    wait_bsy        ; ожидаем готовности устройства
;        xra     A               ; clear carry
        ret

;------------------------------------------------------------------------
; Запись сектора
;------------------------------------------------------------------------
; на входе:
;    curDevice  - номер устройства на канале (0 или 1)
;    absSector  - абсолютный номер сектора
;    HL         - буфер с данными
; на выходе:
;    CF         - 0: нормальное завершение
;                 1: ошибка
ide_WriteSector:
        ; "нормализуем" адрес
        call    ide_getAddress  ; HL - address
        ; отсылаем команду контроллеру
        mvi     A, 30h
        sta     ataCommand
        call    ide_SendParam
        rc
        call    wait_drq        ; ждем готовности устройства к передаче данных
        rc
        ; пишем сектор
        call    ide_WriteBlock
        call    wait_bsy        ; ожидаем готовности устройства
;        xra     A               ; clear carry
        ret


;------------------------------------------------------------------------
; Возвращает корректный адрес для устройсва (CHS или LBA)
;------------------------------------------------------------------------
; на входе:
;    absSector  - абсолютный адрес
; на выходе:
;    DE         - указатель либо на LBA-адрес,
;                 либо на CHS (bits):
;                    0..7  - сектор
;                    8..23 - цилиндр
;                   24..27 - головка
ide_getAddress:
        lxi     D, absSector
        lda     NumHeads
        ani     40h
        rnz
        push    H
        lhld    absSector
        xchg
        lhld    absSector+2     ; HL:DE - absolute sector
        lda     SecPerTrack
        mov     C, A
        mvi     B, 0            ; BC - SecPerTrack
        call    m_Div32
        jc      @adr_Overflow   ; -> переполнение
        mov     A, L
        inr     A               ; Sec = AbsSec % SecPerTrack + 1
        sta     chsAddress      ; bits[0..7] = Sec
        lxi     H, 0            ; HL:DE = AbsSec / SecPerTrack
        lda     NumHeads
        ani     11111b
        mov     C, A            ; BC = NumOfHeads
        mvi     B, 0
        call    m_Div32
        jc      @adr_Overflow   ; -> переполнение
        xchg                    ; HL = Cyl = HL:DE / NumOfHeads
                                ; DE = Head = HL:DE % NumOfHeads
        shld    chsAddress+1    ; bits[8..23] = Cyl
        mov     A, E
        ani     1111b
        sta     chsAddress+3    ; bits[24..27] = Head
        lxi     D, chsAddress
        pop     H
        ret
    @adr_Overflow:
        lxi     H, szOverflow
        jmp     Quit

  szOverflow:   db 13,10,"CRITICAL ERROR: DIVISION OVERFLOW!",13,10,0


;------------------------------------------------------------------------
; Отсылка устройству команды
;------------------------------------------------------------------------
; на входе:
;    curDevice  - номер устройства на канале (0 или 1)
;    ataCommand - код команды
;    DE         - указатель на номер сектора в формате CHS или LBA
;    NumHeads   - бит 6 указывает на режим: 0 - CHS, 1 - LBA
; на выходе:
;    CF         - 0: нормальное завершение
;                 1: ошибка
ide_SendParam:
        push    B
        ; ожидаем готовности устройства
        call    wait_bsy
        jc      @err_SendParam
        ; выбираем устройство и смотрим на его реакцию
        lda     curDevice
        cpi     2
        jnc     @err_SendParam  ; -> неверный номер устройства
        rlc
        rlc
        rlc
        rlc
        ori     10100000b
        mov     B, A
        call    ide_WriteMode  ; режим записи
        di
        OUTP    REG_LOBYTE, B
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 6>
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <0>
        ei
        lda     NumHeads
        ani     40h             ; выделяем бит режима LBA
        ora     B
        mov     B, A
        ; ожидает готовности устройства к приему команды
        call    wait_drdy
        jc      @err_SendParam
        call    ide_WriteMode  ; режим записи
        di
        xchg
        ; загружаем параметры в регистры контроллера
        ; reg 1 - features = 0
        OUTP    REG_LOBYTE, 0
        OUTP    REG_LINE, <LINE_CS0 + 1>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 1>
        OUTP    REG_LINE, <LINE_CS0 + 1>
        OUTP    REG_LINE, <0>
        ; reg 2 - sector count = 1
        OUTP    REG_LOBYTE, 1
        OUTP    REG_LINE, <LINE_CS0 + 2>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 2>
        OUTP    REG_LINE, <LINE_CS0 + 2>
        OUTP    REG_LINE, <0>
        ; reg 3 - addr[0..7]
        OUTP    REG_LOBYTE, M
        inx     H
        OUTP    REG_LINE, <LINE_CS0 + 3>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 3>
        OUTP    REG_LINE, <LINE_CS0 + 3>
        OUTP    REG_LINE, <0>
        ; reg 4 - addr[8..15]
        OUTP    REG_LOBYTE, M
        inx     H
        OUTP    REG_LINE, <LINE_CS0 + 4>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 4>
        OUTP    REG_LINE, <LINE_CS0 + 4>
        OUTP    REG_LINE, <0>
        ; reg 5 - addr[16..23]
        OUTP    REG_LOBYTE, M
        inx     H
        OUTP    REG_LINE, <LINE_CS0 + 5>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 5>
        OUTP    REG_LINE, <LINE_CS0 + 5>
        OUTP    REG_LINE, <0>
        ; reg 6 - addr[24..27]
        mov     A, M            ; addr[24..27]
        ani     00001111b
        ora     B
        OUTP    REG_LOBYTE, A
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 6>
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <0>
        ; reg 7 - command
        lda     ataCommand
        OUTP    REG_LOBYTE, A
        OUTP    REG_LINE, <LINE_CS0 + 7>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 7>
        OUTP    REG_LINE, <LINE_CS0 + 7>
        OUTP    REG_LINE, <0>
        ei
        xchg
        call    ide_ReadMode    ; режим чтения
        xra     A               ; clear carry
        pop     B
        ret
    @err_SendParam:
        call    ide_ReadMode    ; режим чтения
        pop     B
        stc
        ret


;------------------------------------------------------------------------
; ожидание освобождения устройства
;------------------------------------------------------------------------
; На выходе:
;    CF         - 0: устройство готово
;                 1: тайм-аут
wait_bsy:
        push    H
        call    ide_ReadMode    ; режим чтения
        lxi     H, 0FFFFh
    @wait_bsy:
        dcx     H
        mov     A, H
        ora     L
        jz      wait_error
        ; читаем регистр статуса
        call    ide_GetStatus
        ani     80h
        jnz     @wait_bsy

        ; нормальное завершение ожидания
wait_ok:
        pop     H
        xra     A                       ; clear carry flag
        ret
        ; время ожидания вышло
wait_error:
        pop     H
        stc                             ; set carry flag
        ret

;------------------------------------------------------------------------
; ожидание готовности устройства к приему команд
;------------------------------------------------------------------------
wait_drdy:
        push    H
        call    ide_ReadMode    ; режим чтения
        lxi     H, 0FFFFh
    @wait_drdy:
        dcx     H
        mov     A, H
        ora     L
        jz      wait_error
        ; читаем регистр статуса
        call    ide_GetStatus
        ani     11000000b
        cpi     01000000b
        jnz     @wait_drdy
        jmp     wait_ok

;------------------------------------------------------------------------
; ожидание готовности устройства к передаче данных
;------------------------------------------------------------------------
wait_drq:
        push    H
        call    ide_ReadMode    ; режим чтения
        lxi     H, 0FFFFh
    @wait_drq:
        dcx     H
        mov     A, H
        ora     L
        jz      wait_error
        ; читаем регистр статуса
        call    ide_GetStatus
        ani     10001000b
        cpi     00001000b
        jnz     @wait_drq
        jmp     wait_ok


;------------------------------------------------------------------------
; принимает 512 байт данных от устройства
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер на 512 байт
ide_ReadBlock:
        call    ide_ReadMode    ; режим чтения
        push    H
        push    D
        OUTP    REG_LINE, <LINE_CS0>
        mvi     D, 0
        di
    @read_loop:
        ; стробируем чтение
        OUTP    REG_LINE, <LINE_CS0 + LINE_RD>
        ; считываем данные
        INP     M, REG_LOBYTE
        inx     H
        INP     M, REG_HIBYTE
        OUTP    REG_LINE, <LINE_CS0>
        inx     H
        dcr     D
        jnz     @read_loop
ide_EndBlock:
        ei
        call    ide_ReadMode    ; режим чтения
        pop     D
        pop     H
        ret


;------------------------------------------------------------------------
; отправляет 512 байт данных на устройство
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер на 512 байт
ide_WriteBlock:
        push    H
        push    D
        call    ide_WriteMode  ; режим записи
        OUTP    REG_LINE, <LINE_CS0>
        mvi     D, 0
        di
    @write_loop:
        ; загружаем данные в регистры
        OUTP    REG_LOBYTE, M
        inx     H
        OUTP    REG_HIBYTE, M
        inx     H
        ; стробируем запись
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR>
        OUTP    REG_LINE, <LINE_CS0>
        dcr     D
        jnz     @write_loop
        jmp     ide_EndBlock




;------------------------------------------------------------------------
; Сброс дисков
;------------------------------------------------------------------------
; На выходе:
;    CF         - 0: устройство готово
;                 1: никто не откликнулся
ide_Reset:
        call    ide_ReadMode    ; режим чтения
        ; удерживаем линию 1/50 секунды
        lxi     B, 5D1h
    @wrsloop:
        dcx     B
        mov     A, B
        ora     C
        jnz     @wrsloop
        ; сбрасываем устройство и удерживаем линию 1/100 секунды
        OUTP    REG_LINE, <LINE_RESET>
        lxi     B, 5D1h/2
    @rstloop:
        dcx     B
        mov     A, B
        ora     C
        jnz     @rstloop
        OUTP    REG_LINE, <0>
        ; ждем окончания сброса винта
        mvi     B, 8
    @reset_wait:
        call    isBreak         ; проверяем нажатие 'ПРФ'
        dcr     B
        jz      @check_slave
        ; выбираем устройство master
        mvi     C, 10100000b
        call    @dev_is_ready
        jc      @reset_wait            ; устройство не готово, повторим
        ; устройство готово к работе
        xra     A
        ret
    @check_slave:
        ; выбираем устройство slave
        mvi     C, 10110000b
    @dev_is_ready:
        call    ide_WriteMode
        di
        OUTP    REG_LOBYTE, C
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <LINE_CS0 + LINE_WR + 6>
        OUTP    REG_LINE, <LINE_CS0 + 6>
        OUTP    REG_LINE, <0>
        ei
        ; и ждем ответной реакции
        call    wait_drdy
        ret



;========================================================================
;------------------------------------------------------------------------
;------------------------- Сервисные функции ПЗУ ------------------------
;------------------------------------------------------------------------
;========================================================================

;------------------------------------------------------------------------
; выбор текущего логического диска
;------------------------------------------------------------------------
; на входе:
;    A          - номер логического диска [0..numDisks-1]
;    HL         - указатель на структуру DPH
; на выходе:
;    HL         - указатель на структуру DPH диска или 0
;    запись из tblDevices[curDisk]
sv_SetDisk:
        mov     C, A
        lda     numDisks
        dcr     A
        jm      @@not_disk
        cmp     C
        jc      @@not_disk
        push    H
        mov     L, C
        mvi     H, 0            ; HL - logDisk
        dad     H               ; *2
        dad     H               ; *4
        dad     H               ; *8
        push    H
        lxi     D, tblDevices
        dad     D               ; HL = &tblDevices[logDisk]
        lxi     D, curDevice
        lxi     B, 8
        call    5Ch
        pop     H
        dad     H               ; *16
        pop     D
        dad     D               ; HL = &DPH[logDisk]
        ret
    @@not_disk:
        lxi     H, 0
        ret

;------------------------------------------------------------------------
; выбор адреса для последующей операции чтения/записи
;------------------------------------------------------------------------
; на входе:
;       DE      - логический сектор [1..xxxx]
;       HL      - логическая дорожка
sv_SetAddr:
        ; переводим сектора в 512-ти байтные
        dcx     D
        mvi     B, 2
        call    m_Shr16         ; DE >>= 2
        ; вычисляем абсолютный адрес сектора
        lda     shiftTrack
        dcr     A               ; будем переводить в сектора по 512 байт
        dcr     A
        mov     B, A            ; B = count shift
        mvi     C, 0            ; C:HL - номер логической дорожки
    @@shift_track:
        xra     A               ; clear carry
        mov     A, L            ; C:HL << 1
        ral
        mov     L, A
        mov     A, H
        ral
        mov     H, A
        mov     A, C
        ral
        mov     C, A            ; C:HL = track * sec_per_track (sec=512 bytes)
        dcr     B
        jnz     @@shift_track   ; while (--shiftTrack)
        ; прибавляем номер логического сектора
        mov     A, E
        add     L
        mov     L, A
        mov     A, D
        adc     H
        mov     H, A
        mov     A, C
        aci     0
        mov     C, A
        mov     A, B
        aci     0
        mov     B, A            ; BC:HL = (track * (sec_per_track/4)) + (sec/4)
        ; прибавляем адрес начального сектора раздела
        lda     startSec
        add     L
        sta     absSector
        lda     startSec+1
        adc     H
        sta     absSector+1
        lda     startSec+2
        adc     C
        sta     absSector+2
        lda     startSec+3
        adc     B
        sta     absSector+3
        ret

;------------------------------------------------------------------------
; Чтение сектора
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер для чтения (128 байт)
; на выходе:
;    A          - 0: нормальное завершение
;                 1: ошибка
sv_Read:
        call    ide_ReadSector
        mvi     A, 0
        rnc
        inr     A
        ret

;------------------------------------------------------------------------
; Запись сектора
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер с данными (512 байт)
; на выходе:
;    A          - 0: нормальное завершение
;                 1: ошибка
sv_Write:
        call    ide_WriteSector
        mvi     A, 0
        rnc
        inr     A
        ret

;------------------------------------------------------------------------
; подгружает в кеш сектор, если его там не было
;------------------------------------------------------------------------
; на входе:
;    HL         - буфер с кешированным сектором (512 байт)
;    DE         - абсолютный адрес сектора в кэше
; на выходе:
;    A          - 0: нормальное завершение
;                 1: ошибка
sv_cacheSec:
        push    H
        push    D
        lxi     H, absSector
        lxi     B, 4
        call    m_Compare       ; if (absSector != curCache)
        pop     D
        pop     H
        jz      @@cache_done    ;     then READSECTOR(&cacheBuff)
        ; сектор уже в кэше
        push    D
        push    H
        ; подгружаем сектор с диска
        lxi     H, absSector
        lxi     B, 4
        call    5Ch             ; curCache = absSector
        pop     H
        call    ide_ReadSector
        pop     D
        jc      @@cache_error
    @@cache_done:
        xra     A
        ret
    @@cache_error:
        ; ошибка чтения сектора
        mvi     A, 0FFh
        lxi     B, 4
        call    56h             ; помечаем сектор в буфере как недоступный
        mvi     A, 1
        ret

;------------------------------------------------------------------------
; загружает модули BDOS и CPP из ПЗУ в память
;------------------------------------------------------------------------
sv_Load_BDOS_CPP:
        lxi     D, CCP_ADDR
        lxi     H, BEGINCPM
        lxi     B, SYS_SIZE     ; модули BDOS и CCP
        call    5Ch
        ret

;------------------------------------------------------------------------
; Чтение символа с консоли
;------------------------------------------------------------------------
; на выходе:
;    A          - символ
sv_CONIN:
        lda     cursorStatus
        ora     a
        cnz     0A1h            ; включить изображение курсора
        xra     a
        sta     conOp
        call    7Ch             ; функция ввода символа с клавиатуры
        ret

;------------------------------------------------------------------------
; Вывод символа на консоль
;------------------------------------------------------------------------
; на входе:
;    A          - символ
; прим.: обрабатывает последовательности <ESC>:
;    <ESC>A - перемещение курсора вверх на строку
;    <ESC>B - перемещение курсора вниз на строку
;    <ESC>C - перемещение курсора вправо на знакоместо
;    <ESC>D - перемещение курсора влево на знакоместо
;    <ESC>E - очистка экрана и перемещение курсора в 0,0
;    <ESC>H - перемещение курсора в 0,0
;    <ESC>Y<y><x> - прямое позиционирование курсора в 32-y, 32-x
sv_CONOUT:
        push    H
        push    D
        mov     C, A
        lda     cursorStatus
        ora     A
        cz      9Eh             ; выключить изображение курсора
        ; проверяем на предмет ESC-последовательности
        lda     conOp
        ora     A
        jnz     @@do_ESC        ; -> была начата последовательность ESC
        mov     A, C
        cpi     1Bh             ; ESC?
        jnz     @@put_char
        mvi     A, 1            ; начата последовательность ESC
        jmp     @@store_Op
    @@put_char:
        mov     A, C
    @@put_char_a:
        call    3Bh             ; вывод символа на экран
    @@zero_Op:
        xra     A
    @@store_Op:
        sta     conOp
        pop     D
        pop     H
        ret

    @@do_ESC:   ; парсим последовательность ESC
        cpi     2
        mov     A, C
        jnc     @@is_op3
        cpi     'Y'             ; <ESC>Y<y><x> (прямое позиционирование курсора)?
        mvi     A, 2
        jz      @@store_Op
        mov     A, C
        cpi     'A'
        jc      @@zero_Op
        cpi     'I'
        jnc     @@zero_Op       ; if (symb >= <ESC>A) && (symb < <ESC>I)
        dcr     A               ; symb--
        ani     7               ; symb = (symb-1) & 0b00000111
        lxi     H, tblOp
        add     L
        mov     L, A
        mov     A, M            ; A - код операции, поддерживаемый BIOS'ом
        jmp     @@put_char_a
  @@is_op3:
        jz      @@op_2
        mvi     A, 32           ; Op = 3
        sub     C
        mov     E, A            ; позиция на строке
        lda     firstESCPar
        mov     D, A            ; строка
        mvi     A, 1
        call    50h             ; установка курсора
        jmp     @@zero_Op
    @@op_2:
        mvi     A, 32           ; Op = 2
        sub     C
        sta     firstESCPar
        mvi     A, 3
        jmp     @@store_Op
tblOp:  db 1Eh          ; <ESC>A - перемещение курсора вверх на строку
        db 1Fh          ; <ESC>B - перемещение курсора вниз на строку
        db 1Ch          ; <ESC>C - перемещение курсора вправо на знакоместо
        db 1Dh          ; <ESC>D - перемещение курсора влево на знакоместо
        db 0Ch          ; <ESC>E - очистка экрана и перемещение курсора в 0,0
        db 0            ; <ESC>F
        db 0            ; <ESC>G
        db 0Bh          ; <ESC>H - перемещение курсора в 0,0

;------------------------------------------------------------------------
; инициализация переменных подпрограмм ПЗУ
;------------------------------------------------------------------------
sv_Reset:
        xra     A
        sta     conOp
        sta     firstESCPar
        inr     A
        sta     cursorStatus
        ret



;========================================================================
;------------------------------------------------------------------------
;------------ Подпрограммы извлечения информации о устройстве -----------
;------------------------------------------------------------------------
;========================================================================

;------------------------------------------------------------------------
; распаковывает название модели в строку
;------------------------------------------------------------------------
; на входе:
;    HL         - идентификационные данные от устройства (команда 0xEC)
;    DE         - буфер под строку
;    B          - длина строки
; на выходе:
;    DE         - указатель на конец буфера (сразу за последним символом)
inf_UnpackModel:
        push    H
        mov     A, B
        lxi     B, 27*2
        dad     B               ; HL - указатель на модель устройства
        rar
        ani     01111111b
        mov     B, A            ; считаем по словам
    @unp_loop:
        mov     C, M
        inx     H
        mov     A, C
        ora     M
        jz      @unp_exit
        mov     A, M
        inx     H
        stax    D
        inx     D
        mov     A, C
        stax    D
        inx     D
        dcr     B
        jnz     @unp_loop
    @unp_exit:
        pop     H
        ret

;------------------------------------------------------------------------
; извлекает количество цилиндров в строку
;------------------------------------------------------------------------
; на входе:
;    HL         - идентификационные данные от устройства (команда 0xEC)
;    DE         - буфер под строку
; на выходе:
;    DE         - указатель на конец буфера (сразу за последним символом)
inf_GetCylinders:
        push    H
        lxi     B, 1*2
        dad     B
        mvi     A, '/'
        jmp     inf_ConvWord
; извлекает количество головок в строку
inf_GetHeads:
        push    H
        lxi     B, 3*2
        dad     B
        mvi     A, '/'
        jmp     inf_ConvWord
; извлекает количество секторов в строку
inf_GetSectors:
        push    H
        lxi     B, 6*2
        dad     B
        xra     A
inf_ConvWord:
        push    PSW
        ; подгружаем слово
        mov     A, M
        inx     H
        mov     H, M
        mov     L, A
        ; конвертируем в строку
        call    utoa
        ; добавляем символ-разделитель
        pop     PSW
        pop     H
        ora     A
        rz
        stax    D
        inx     D
        ret


;------------------------------------------------------------------------
; извлекает/вычисляет размер диска
;------------------------------------------------------------------------
; на входе:
;    HL         - идентификационные данные от устройства (команда 0xEC)
;    DE         - буфер под строку
;    A          - флаг: 1 - LBA, 0 - CHS
; на выходе:
;    DE         - указатель на конец буфера (сразу за последним символом)
inf_GetSize:
        push    H
        push    D
        ora     A
        jz      @size_chs
        ; режим LBA
        lxi     D, 60*2
        dad     D
        mov     C, M
        inx     H
        mov     B, M
        inx     H
        mov     E, M
        inx     H
        mov     D, M
        mov     L, C
        mov     H, B            ; DE:HL - total sectors in LBA mode
        jmp     @size_sec_to_mb
    @size_chs:  ; режим CHS
        push    H
        lxi     D, 3*2
        dad     D
        mov     C, M
        inx     H
        mov     B, M
        dcx     H
        dad     D
        mov     E, M
        inx     H
        mov     D, M
        call    m_Mul16         ; DE:HL - SecPerTracks * Heads
        xchg
        pop     H
        lxi     B, 1*2
        dad     B
        mov     C, M
        inx     H
        mov     B, M
        call    m_Mul16         ; DE:HL - Cylinders * (SecPerTracks * Heads)
        ; переводим сектора в мегабайты
    @size_sec_to_mb:
        mvi     B, 11
        call    @size_rshift
        mov     A, E
        ora     D
        lxi     B, szMB
        jz      @size_put
        mvi     B, 10
        call    @size_rshift
        lxi     B, szGB
    @size_put:
        pop     D
        call    utoa
        mov     L, C
        mov     H, B
        lxi     B, 3
        call    5Ch
        pop     H
        ret

  ; сдвиг DE:HL на B бит
  @size_rshift:
        xra     A
        mov     A, D
        rar
        mov     D, A
        mov     A, E
        rar
        mov     E, A
        mov     A, H
        rar
        mov     H, A
        mov     A, L
        rar
        mov     L, A
        dcr     B
        jnz     @size_rshift
        ret

szMB:   db " Mb"
szGB:   db " Gb"


;------------------------------------------------------------------------
; выводит на экран информацию по найденному устройству
;------------------------------------------------------------------------
; на входе:
;    HL         - идентификационные данные от устройства (команда 0xEC)
inf_Print:
        ; заносим в буфер модель
        lxi     D, strBuff
        mvi     B, MAX_NAME_LEN
        call    inf_UnpackModel
        ; теперь размер устройства
        push    H
        lxi     H, szSize
        lxi     B, len_size
        call    5Ch
        pop     H
        lda     NumHeads
        ani     40h
        push    PSW
        call    inf_GetSize
        ; теперь режим (LBA/CHS)
        pop     PSW
        push    H
        push    PSW
        lxi     H, szLBA
        jnz     @print_mode
        lxi     H, szCHS
    @print_mode:
        lxi     B, len_mode
        call    5Ch
        pop     PSW
        pop     H
        jnz     @print_showinfo
        call    inf_GetCylinders
        call    inf_GetHeads
        call    inf_GetSectors
    @print_showinfo:
        ; завершаем строку и выводим ее на экран
        lxi     H, szCRLF
        lxi     B, 3
        call    5Ch
        lxi     H, strBuff
        mvi     A, 2
        call    50h
        ret

szLBA:  db 13,10,9, "Mode: LBA     "
szCHS:  db 13,10,9, "Mode: C/H/S - "
        len_mode equ $-szCHS
szSize: db 13,10,9, "Size: "
        len_size equ $-szSize



;========================================================================
;------------------------------------------------------------------------
;--------------------- Вспомогательные подпрограммы ---------------------
;------------------------------------------------------------------------
;========================================================================

;------------------------------------------------------------------------
; провряет считанный сектор на наличие системной сигнатуры
;------------------------------------------------------------------------
; на входе:
;    HL         - сектор (S)MBR
; на выходе:
;    CF         - 0: есть сигнатура 0xAA55h
;                 1: сигнатуры нет
ide_CheckSign:
        push    H
        lxi     B, 1FEh
        dad     B
        mov     A, M
        cpi     55h
        jnz     @no_sign
        inx     H
        mov     A, M
        cpi     0AAh
        jnz     @no_sign
        xra     A
        pop     H
        ret
    @no_sign:
        stc
        pop     H
        ret

;------------------------------------------------------------------------
; вычисляет величину сдвига номера цилиндра для умножения на SecPerTrack
;------------------------------------------------------------------------
; на входе:
;   HL      - &DBP
;   DE      - адрес переменной для результата
calck_Shift:
        push    D
        mov     A, M
        mov     C, A
        inx     H
        mov     A, M
        mov     B, A            ; BC - SecPerTrack
        mvi     D, 0            ; D  - shift
        lxi     H, 1            ; HL = 1 << shift
    @@calcksh_loop:
        dad     H               ; HL <<= 1
        inr     D
        mov     A, H
        cmp     B
        jnz     @@calcksh_loop
        mov     A, L
        cmp     C
        jnz     @@calcksh_loop
        mov     A, D
        pop     D
        stax    D
        inx     D
        ret


;------------------------------------------------------------------------
; перевод беззнакового числа в строку
;------------------------------------------------------------------------
; на входе:
;    HL         - 16-битное число
;    DE         - буфер под ascii-строку
utoa:
        push    B
        mvi     A, '0'          ; флаг пропуска первых нулей
        lxi     B, -10000
        call    @@dectoa
        lxi     B, -1000
        call    @@dectoa
        lxi     B, -100
        call    @@dectoa
        lxi     B, -10
        call    @@dectoa
        mov     A, L
        ori     '0'
        stax    D
        inx     D
        pop     B
        ret
  @@dectoa:
        push    D
        mov     D, A
        mvi     A, '0'-1
    @@decialoop:
        inr     A
        dad     B
        jc      @@decialoop
        push    PSW
        mov     A, L
        sbb     C
        mov     L, A
        mov     A, H
        sbb     B
        mov     H, A
        pop     PSW
        cmp     D
        pop     D
        rz
        stax    D
        inx     D
        mvi     A, 0FFh         ; закончили пропуск нулей
        ret



;========================================================================
;------------------------------------------------------------------------
;------------------------------ Арифметика ------------------------------
;------------------------------------------------------------------------
;========================================================================

;------------------------------------------------------------------------
; сравнивает два блока на равенство
;------------------------------------------------------------------------
; на входе:
;    HL, DE     - блоки памяти
;    BC         - длина
; на выходе:
;    ZF         - 0: не равны
m_Compare:
        ldax    D
        cmp     M
        rnz
        inx     D
        inx     H
        dcx     B
        mov     A, B
        ora     C
        jnz     m_Compare
        ret


;------------------------------------------------------------------------
; копирует 32-х разрядное число из [HL] в [DE]
;------------------------------------------------------------------------
m_Copy32:
        push    B
        lxi     B, 4
        call    5Ch
        pop     B
        ret

;------------------------------------------------------------------------
; инкремент 32-х разрядного чисела
;------------------------------------------------------------------------
; на входе:
;    HL         - слагаемое и результат
m_Inc32:
        push    H
        push    B
        lxi     B, nOne
        jmp     m_doAdd32
        nOne:   db 1,0,0,0

;------------------------------------------------------------------------
; сложение 32-х разрядных чисел
;------------------------------------------------------------------------
; на входе:
;    HL         - первое слагаемое и результат
;    BC         - второе слагаемое
; на выходе:
;    HL         - HL+BC
;    CF         - флаг переполнения результата
m_Add32:
        push    H
        push    B
  m_doAdd32:
        ldax    B
        add     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        pop     B
        pop     H
        ret


;------------------------------------------------------------------------
; деление 32-х разрядного числа на 16-ти разрядное
;------------------------------------------------------------------------
; на входе:
;    HL:DE      - делимое
;    BC         - делитель
; на выходе:
;    DE         - частное
;    HL         - остаток
;    cf         - 1: произошло переполнение результата
m_Div32:
        mov     A, L
        sub     C
        mov     A, H
        sbb     B
        cmc
        rc                      ; возврат, переполнение
        xra     A               ; A - счетчик бит
    @@div_loop:
        dad     H               ; сдвигаем остаток влево
        push    PSW
        xchg
        dad     H               ; сдвигаем младшую часть делимого
        xchg
        jnc     @@div_1         ; -> из младшей части выдвинут ноль
        inx     H               ;                              единица
    @@div_1:
        mov     A, L            ; вычитаем делитель из остатка
        sub     C
        mov     L, A
        mov     A, H
        sbb     B
        mov     H, A
        jc      @@div_2         ; -> цифра частного равна нулю
        pop     PSW
    @@div_3:
        inx     D               ; цифра частного равна единице
        jmp     @@div_4
    @@div_2:
        pop     PSW
        jc      @@div_3
        dad     B               ; восстанавливаем остаток
    @@div_4:
        adi     10h             ; инкремент счетчика бит
        jnc     @@div_loop
        ora     A               ; сброс флага переполнения
        ret


;------------------------------------------------------------------------
; умножение двух 16-битных чисел
;------------------------------------------------------------------------
; на входе:
;    BC         - множимое
;    DE         - множитель
; на выходе:
;    DE:HL      - произведение
m_Mul16:
        lxi     H, 0
        mvi     A, 16
    @mul_loop:
        xchg
        dad     H
    @mul1:
        xchg
        jnc     @mul_noadd
        dad     B
        jnc     @mul_noadd
        inx     D
    @mul_noadd:
        dcr     A
        rz
        dad     H
        jnc     @mul_loop
        xchg
        dad     H
        inx     H
        jmp     @mul1


;------------------------------------------------------------------------
; сдвиг DE вправо на B бит
;------------------------------------------------------------------------
m_Shr16:
        xra     A
        mov     A, D
        rar
        mov     D, A
        mov     A, E
        rar
        mov     E, A
        dcr     B
        jnz     m_Shr16
        ret



;========================================================================
;------------------------------------------------------------------------
;-------------------------------- Данные --------------------------------
;------------------------------------------------------------------------
;========================================================================


  crcCode:      db 256-77       ; байт crc

BEGINCPM:

include data.i80


END
